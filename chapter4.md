# chapter4

## 4.1

表达式`5 + 10 * 20 / 2`的求值结果是多少？

`5 + 10 * 20 / 2 = 5 + ((10 * 20) / 2) = 105`

## 4.2

根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。 (a) `*vec.begin()` (b) `*vec.begin() + 1`



(a) `(*vec.begin())` (b) `(*vec.begin()) + 1`

## 4.3

C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。

解：

可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。

## 4.4

在下面的表达式中添加括号，说明其求值过程及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。

```
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
```

解：

```
((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2) = 16 + 75 + 0 = 91
```

## 4.5

写出下列表达式的求值结果。

```c++
-30 * 3 + 21 / 5  // -90+4 = -86
-30 + 3 * 21 / 5  // -30+63/5 = -30+12 = -18
30 / 3 * 21 % 5   // 10*21%5 = 210%5 = 0
-30 / 3 * 21 % 4  // -10*21%4 = -210%4 = -2
```

## 4.6

写出一条表达式用于确定一个整数是奇数还是偶数。

```c++
if (i % 2 == 0) /* ... */
```

## 4.7

当计算的结果超出该类型所能表示的范围时就会产生溢出。

```c++
short svalue = 32767; ++svalue; // -32768
unsigned uivalue = 0; --uivalue;  // 4294967295
unsigned short usvalue = 65535; ++usvalue;  // 0
```

## 4.8

说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。

解：

- 逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 **短路求值**。
- 相等性运算符未定义求值顺序。

## 4.9

解释在下面的`if`语句中条件部分的判断过程。

```c++
const char *cp = "Hello World";
if (cp && *cp)
```

首先判断`cp`，`cp` 不是一个空指针，因此`cp`为真。然后判断`*cp`，`*cp` 的值是字符`'H'`，非0。因此最后的结果为真。

## 4.10

为`while`循环写一个条件，使其从标准输入中读取整数，遇到`42`时停止。

解：

```c++
int i;
while(cin >> i && i != 42)
```


## 4.11

书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。

解：

```c++
a>b && b>c && c>d
```

## 4.12

假设`i`、`j`和`k`是三个整数，说明表达式`i != j < k`的含义。

解：

这个表达式等于`i != (j < k)`。首先得到`j < k`的结果为`true`或`false`，转换为整数值是`1`或`0`，然后判断`i`不等于`1`或`0` ，最终的结果为`bool`值。

## 4.13

在下述语句中，当赋值完成后 i 和 d 的值分别是多少？

```c++
int i;   double d;
d = i = 3.5; // i = 3, d = 3.0
i = d = 3.5; // d = 3.5, i = 3
```

## 4.14

执行下述 if 语句后将发生什么情况？

```c++
if (42 = i)   // 编译错误。赋值运算符左侧必须是一个可修改的左值。而字面值是右值。
if (i = 42)   // true.
```

## 4.15

下面的赋值是非法的，为什么？应该如何修改？

```c++
double dval; int ival; int *pi;
dval = ival = pi = 0;
```



解： `p`是指针，不能赋值给`int`，应该改为：

```c++
dval = ival = 0;
pi = 0;
```

## 4.16

尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？

```c++
if (p = getPtr() != 0)
if (i = 1024)
```

解：

```c++
if ((p=getPtr()) != 0)
if (i == 1024)
```

## 4.17

说明前置递增运算符和后置递增运算符的区别。

解：

**前置递增运算符将对象本身作为左值返回，而后置递增运算符将对象原始值的副本作为右值返回。**

## 4.18

如果132页那个输出`vector`对象元素的`while`循环使用前置递增运算符，将得到什么结果？

解：

将会从第二个元素开始取值，并且最后对`v.end()`进行取值，结果是未定义的。

## 4.19

假设`ptr`的类型是指向`int`的指针、`vec`的类型是`vector`、`ival`的类型是`int`，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？

```c++
(a) ptr != 0 && *ptr++  
(b) ival++ && ival
(c) vec[ival++] <= vec[ival] 
```


(a) 判断`ptr`不是一个空指针，并且`ptr`当前指向的元素的值也为真，然后将`ptr`指向下一个元素

(b) 判断`ival`的值为真，并且`(ival + 1)`的值也为真

(c) 表达式有误。C++并没有规定`<=`运算符两边的求值顺序，应该改为`vec[ival] <= vec[ival+1]`



**这题好**

## 4.20

假设`iter`的类型是`vector<string>::iterator`, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？

```
(a) *iter++;
(b) (*iter)++;
(c) *iter.empty();
(d) iter->empty();
(e) ++*iter;
(f) iter++->empty();
```



解：

- (a)合法。返回迭代器所指向的元素，然后迭代器递增。
- (b)不合法。因为`vector`元素类型是`string`，没有`++`操作。
- (c)不合法。这里应该加括号。
- (d)合法。判断迭代器当前的元素是否为空。
- (e)不合法。`string`类型没有`++`操作。
- (f)合法。判断迭代器当前元素是否为空，然后迭代器递增。

## 4.21

