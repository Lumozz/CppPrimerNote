# 动态内存与智能指针

## 基本概念

内存分为静态内存、栈内存、堆内存

- 静态内存：保存局部static对象、类static数据成员，定义在任何函数之外的变量。
- 栈内存： 保存自定义在函数内的非static对象。分配在此的对象由编译器自动创建和销毁。
- 堆（自由空间、动态内存）：程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。对象的创建和销毁由程序来控制。

## 动态内存的使用、缺陷、弥补方法

### 使用

动态内存的管理是通过一对运算符来完成的：

- `new` 创建对象，在动态内存中为对象分配空间，并返回一个指向该对象的**指针**。
- `delete`销毁对象，接受一个动态对象的**指针**，并释放与之关联的内存。

### 缺陷

难以保证在正确的时候销毁对象。

- 如果只创建不销毁，程序会用光内存，产生**内存泄漏**。

- 如果提前销毁了还需使用的对象，会产生引用非法内存指针的错误。

### 弥补

为了解决上述问题，c++11提出了两种智能指针，负责自动释放所指向的对象，两种智能指针的区别在于管理底层指针的方式。

- `shared-ptr`：允许多个指针指向同一个对象。
- `unique_ptr`： 一个对象最多被一个智能指针指向。
- `weak_ptr`：弱引用，指向`shared_ptr`所管理的对象。

## `shared_ptr`类

### 基本原理

当进行拷贝或赋值操作时，每个`shared_ptr`都会记录有多少个其他`shared_ptr`指向相同对象。当指向一个对象的最后一个`shared_ptr`被销毁时，`shared_ptr`类会自动销毁此对象。

- `shared_ptr`可以协调对象的析构，但仅限于其自身的拷贝。

### 创建

智能指针也是模板，创建智能指针时，并需提供**指向对象类型**的信息。

- 初始化一个空指针，然后赋值（让该指针指向一个对象）

  ```c++
  shared_ptr<string> p1; // 指向string类型
  shared_ptr<list<int>> p2; //指向int的list
  
  if (p1 && p1->empty())
    *p1 = "hi";
  ```

- 直接生成一个指向**新对象**的指针（`make_shared`）

  最安全的分配和使用动态内存的方法是使用`make_shared`标准库函数，该函数在动态内存中分配一块内存给新对象，然后初始化它，最后返回指向此对象的`shared_ptr`

  ```c++
  //指向一个值为42的int的shared_ptr
  shared_ptr<int> p3 = make_shared<int>(42);
  //p4指向一个值为“9999999999”的string
  shared_ptr<string> p4 = make_shared<string>(10,'9');
  //p5指向一个值初始化的int
  shared_ptr<int> p5 = make_shared<int>()
  ```

  `make_shared`用其入参来构造给定类型的对象。如果不传递任何参数，对象就会进行值初始化。

  通常用`auto`来保存`make_shared`的返回结果。毕竟`make_shared`的参数中，已经有足够多的信息让阅读代码的人知道返回的是什么类型的对象。

## `unique_ptr`类

### 创建

某个时刻只能有一个`unique_ptr`指向一个给定对象。因此，它**不支持普通的拷贝或赋值操作**。

- 例外：可以拷贝或赋值一个将要被销毁的`unique_ptr`，例如函数返回一个`unique_ptr`.

当我们定义一个`unique_ptr`时，需要将其绑定到一个`new`返回的指针上。必须使用直接初始化的方式。

```c++
unique_ptr<int> p1;
unique_ptr<int> p2(nwe int(42));
```

要转移指针的**所有权**，可以通过使用`release`或`reset`.

```c++
unique_ptr<string> p2(p1.release()); //将所有权从p1移交给p2

unique_ptr<string> p2(new string("Trex"));
p2.reset(p3.release()); // 将所有权从p2移交给p3,将p3置为空。
```



# 动态数组

## 基本概念

- c++定义了另一种`new`语法，可以分配并初始化一个对象数组，即**动态数组**
- 分配动态数组后，返回的是一个元素类型的指针，**没有长度信息**。这就意味着，不能对动态数组调用`.begin()``.end()`，也不能用范围`for`。
- 动态数组不是数组类型。

## 创建

```c++
int *pia = new int[10];				//10个未初始化的int
int *pia2 = new int[10]();			//10个值初始化为0的int
string *psa = new string[10];		//10个空string
string *psa2 = new string[10]();	//10个空string

int *pia3 = new string[10]{0,1,2,3,4}
```

数组长度可以是一个变量：

```c++
int size = 10;
int *p = new int[size];
```

该变量也可以为0，但是不能解引用返回的指针。

## 释放

使用`delete []`来释放：

```c++
delete p;		//p必须指向一个动态分配的对象或为空
delete [] pa;	//pa必须指向一个动态分配的数组或为空
```

## 用智能指针管理动态数组

### 用`unique_ptr`管理

在对象类型后面跟一对空的方括号

```c++
unique_ptr<int[]> up(new int[10]);
up.release();	//自动用delete []销毁其指针
```

### 用`shared_ptr`管理

`shared_ptr`不直接支持管理动态数组。如果希望使用其管理动态数组，必须定义自己的删除器。

## allocator类

使用`new`构造动态数组，会将内存分配和构造对象组合在一起。如果希望将内存分配和对象构造分离。

