# 拷贝、赋值、销毁

## 基本概念

一个类，通过定义**五种**特殊的成员函数来控制对此类型**拷贝、移动、赋值和销毁**时做什么。

- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

### 直接初始化与拷贝初始化

1.  直接初始化：

	- 使用圆括号`()`或花括号`{}`直接初始化一个对象。

	- 直接初始化时，编译器会直接调用构造函数（默认构造函数、带参数的构造函数、拷贝构造函数），实际上是要求编译器使用普通的函数匹配，根据我们提供的参数，选择最合适的构造函数。

	- ```c++
		MyClass obj1(10);  // 使用单个参数的构造函数
		MyClass obj2{20};  // 统一初始化（C++11）
		```

2. 拷贝初始化

	- 使用等号`=`进行初始化
	
	- 首先创建一个临时对象，然后把这个临时对象拷贝到正在创建的对象中
	
	- 可能会进行类型转换
	
	- 然后编译器会调用构造函数（默认构造函数、带参数的构造函数、拷贝构造函数等）初始化对象
	
	- ```c++
		MyClass obj3 = 30;  // 拷贝初始化
		```
	
	常见的函数传参，不论是传入还是传出参数，只要对象类型不是引用，那么就会执行拷贝初始化。因此，拷贝构造函数的参数类型**必须是引用类型**，否则就是把钥匙锁在了箱子里。

### 何时需要自定义 拷贝构造函数、拷贝赋值运算符和析构函数

- 如果一个类需要自定义拷贝构造函数，则通常也需要自定义拷贝赋值运算符；反之亦然
	- 因为这两者的用处是高度相似的。

- 如果需要自定义析构函数，通常需要自定义拷贝构造函数和拷贝赋值运算符；反之则未必
	- 通常，在类中使用了动态内存时，才会需要自定义析构函数。而编译器自动生成的拷贝构造函数和拷贝赋值运算符，只会简单的复制成员的值。如果对象中有成员是指向动态内存变量的指针，那么复制这个对象，就会有两个指针指向同一个对象。就很有可能产生错误。

## 拷贝构造函数

### 定义与用途

拷贝构造函数，用于创建一个新对象为现有对象的副本。

当一个对象以值的方式传递给函数，从函数返回，或者用另一个同类型的对象进行初始化时，会调用拷贝构造函数。

### 特点

- 形参：一个同类型对象的引用（常常是常亮引用）。
- 构造新对象：新对象的成员值，从传入拷贝构造函数的对象中复制而来。
- 默认拷贝构造函数：如果没有显式定义拷贝构造函数，编译器会自动生成一个，执行**浅拷贝**。

- 浅拷贝和深拷贝

	- 浅拷贝：简单复制每个成员，对非指针和非动态分配的成员，通常不会引发问题。对于指针类型的成员，浅拷贝只会复制指针的值，而不会复制指针所指向的内存。这意味着两个对象将共享相同的内存地址。	
	- 深拷贝：对于指针类型的成员，深拷贝不仅复制指针的值，还会创建指针所指向数据的一个新的副本。

- ```c++
	class MyClass {
	public:
	    MyClass(const MyClass &other) {
	        // 拷贝构造函数的内容，通常涉及复制other的成员到新对象
	    }
	};
	```

## 拷贝赋值运算符

### 定义与用途

拷贝赋值运算符，用于定义一个对象如何通过“赋值”`=`操作符从一个同类型对象那里复制数据。

当把一个对象赋值给另一个已经存在的对象时，就会调用拷贝赋值运算符。

```c++
class Foo {
public:
	Foo& operator=(const Foo&); //赋值运算符
    
    return *this
}
```

## 析构函数

### 作用

- 在对象最后一次使用之后，析构函数首先执行函数体，然后按照初始化顺序，**逆序**销毁所有成员。
- 调用时机：无论何时一个对象被销毁，就会自动调用其析构函数。
	- 变量在离开作用域时被销毁
	- 一个对象被销毁时，其成员被销毁
	- 容器被销毁时，其元素被销毁
	- 对**动态分配**的对象，当对指向它的指针使用`delete`运算符时被销毁。
	- 对临时对象，当创建他的完整表达式结束时被销毁

### 合成析构函数

- 合成析构函数**不会`delete`一个指针数据成员**

- 如果希望`delete`一个指针数据成员，那么应该自定义析构函数。

### 默认析构函数（`=default`）

可以使用`=default`来显示要求编译器使用合成析构函数（或其它有合成版本的成员函数）。注意，由于**析构函数不能重载**对析构函数使用`=default`后，就不能再定义自己的析构函数了。

## 阻止拷贝的两种方法

### 用途

不希望一个对象可以被拷贝

### 定义删除的函数

- 删除的函数是指，虽然声明了他们，但是通知编译器，不能以任何方式使用它们。

- ```c++
	struct NoCopy{
		NoCopy() = default;
		NoCopy(const NoCopy&) = delete;		//阻止拷贝
		NoCopy &operator = (const NoCopy&) = delete;	//阻止拷贝赋值
	}
	```

### private拷贝控制

- 把拷贝构造函数和拷贝赋值运算符声明为`private`（声明但不定义）。

# 拷贝控制和资源管理

## 基本概念

- 如果一个类中的成员都是“值”，那么拷贝类对象时，我们通常希望直接拷贝这个“值”。
- 如果一个类中的成员包含指向某个动态内存位置的“**指针**”，那么我们希望：
	- 直接复制这个指针，此时拷贝前后的两个类对象**同时**指向一个动态内存地址。
	- 把动态内存地址中的内容也复制一份，使两个类对象指向不同的动态内存地址，两个地址中的内容相同。

为了实线这两种不同的拷贝效果，需要使用上一节中的工具，自定义类的拷贝行为，称之为**拷贝控制和资源管理**

